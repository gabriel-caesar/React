import bcrypt from 'bcryptjs';

import type { Request, Response } from 'express';
import type { ValidationReturn } from '../lib/types.ts';

import { formValidation, generateUsername } from '../lib/utils.ts';
import { SignUpSchema, LogInSchema } from '../lib/schemas.ts';
import { getDb } from '../db.ts';

export async function signUp(req: Request, res: Response): Promise<Response> {

  // Validating data
  const validatedFields = formValidation(SignUpSchema, req, res);
  const { email, password } = validatedFields as ValidationReturn;

  // Getting the database instance
  const db = getDb();
  if (!db) throw new Error(`Couldn't get database from multiplayer controller`);

  // Check if there is a user with the same email
  const duplicateEmail = await db.collection('users').findOne({ email: email })
  if (duplicateEmail)
    return res.status(422).json({ errors: [['This email is already being used']] });


  const hashedPassword = await bcrypt.hash(password, 10);
  
  const autoGeneratedUsername = generateUsername(email);

  // Adds brand new user to db
  await db
    .collection('users')
    .insertOne({
      username: autoGeneratedUsername,
      email: email,
      password: hashedPassword
    })

  return res.status(200).json({ successs: true });
}

export async function logIn(req: Request, res: Response): Promise<Response> {
  const validatedFields = formValidation(LogInSchema, req, res);
  const { email, password } = validatedFields as ValidationReturn;

  // Getting the database instance
  const db = getDb();
  if (!db) throw new Error(`Couldn't get database from multiplayer controller.`);

  const user = await db.collection('users').findOne({ email: email });

  if (!user) throw new Error(`Couldn't get user from database.`);

  const isValid = await bcrypt.compare(password, user.password)

  if (isValid)
    return res.status(200).json({ success: true });
  else 
    return res.status(401).json({ errors: ['Invalid credentials'] }) // Copying how Zod returns errors
}