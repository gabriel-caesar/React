'use server'

import OpenAI from 'openai';
import {
  aiChatHistoryType,
  Conversation,
  Message,
  User,
} from '@/app/lib/definitions';
import postgres from 'postgres';
import { dietFormDataType } from '@/public/plan_metadata/diet-formdata';

const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });

// handles user request upon sending a message to the AI
export async function handleRequest(
  req: Request,
  openai: OpenAI,
  conversationId: string
) {
  const {
    prompt,
    user,
    date,
    localMessages,
    signal,
  }: {
    prompt: string;
    user: User;
    date: string;
    localMessages: Message[];
    signal: string;
  } = await req.json();

  // conversation title
  let conversationTitle: string = '';

  const conversationRules = `
    Rule 1: You are Diversus, an AI assistant for a fitness and diet planning web app. Your role is to interact with the user, guide them, and gather the information needed to build their workout or diet plan. Your name, derived from the Latin word for “different,” reflects your purpose: helping individuals become a stronger, improved version of themselves through better living.
    Rule 2: Use Markdown language for your messages.
    Rule 3: Use "\n" for new lines.
    Rule 4: Don't use markdown tables.
    Rule 5: Refer naturally to the conversation history when relevant.
    Rule 6: Call the user by their first name: ${user.firstname}.
    Rule 7: Never send images.
    Rule 8: If the signal is "suggest" it means the application was suggested to initiate the plan form filling and a plan creation will be put on to work. Your response should be aligned with that.
    Rule 9: If the signal is a JSON formatted form data, you shall translate it into markdown and send it to the user.
    Rule 10: The markdown translation should include all data from the JSON form data without exception.
    Rule 11: You will include every single detail provided from the JSON plan in the markdown text you generate.
    Rule 12: You should include the user metadata in the markdown translation as well.
      Diet Metadata: (plan_type, goal, gender, current_weight, height, weight, activity_level, number_of_meals, meal_timing, duration_weeks, want_supplements, daily_caloric_intake, dietary_restrictions and user_notes).
      Workout Metadata: (plan_type, goal, gender, current_weight, height, weight, experience_level, duration_weeks, number_of_workout_days and user_notes).
    Rule 13: The user may ask you to open the plan form and you shall answer that you will.
    Rule 14: You may help the user with any doubts about the form filling, but you can't fill it for them, just direct them how to do so. The form has as many question as the diet or workout metadata options.
    Rule 15: Avoid being too verbose.
    Signal: ${signal}.
  `;

  try {
    // all messages from the current conversation history
    const allMessages = await getConversationHistory(localMessages);

    if (conversationId) {
      // if there is a valid conversation, save the user message into it
      await saveConversationData(conversationId, date, prompt);
    } else {
      // trying to get a new conversation title
      conversationTitle = await getConversationContext(
        prompt,
        openai,
        signal
      );
      // create a brand new conversation and insert the first user message into it if there is no conversation
      if (!conversationTitle.match(/false/i)) {
        await createNewConversation(localMessages, date, conversationTitle, user);
      }
    }

    // getting the response from the AI
    const response = await openai.chat.completions.create({
      messages: [
        {
          role: 'system',
          content: conversationRules,
        },
        ...allMessages,
        {
          role: 'user',
          content: prompt,
        },
      ],
      model: 'gpt-4.1',
      stream: true,
    });

    // creating a brand new readable stream
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder(); // UTF-8 encoder
        try {
          if (response) {
            for await (const chunk of response) {
              // partial string texts generated by the AI (content is the string inside the chunk)
              const content = chunk.choices[0]?.delta?.content || '';
              // encoding the strings to UTF-8 to be sent down the stream (content is the string inside the chunk)
              controller.enqueue(encoder.encode(content));
            }
          }
        } catch (error) {
          throw new Error(`Error: ${error}`);
        } finally {
          controller.close();
        }
      },
    });

    // You need to come up with a way to send the brand new conversation
    // object back to ai-chat.ts main function in order for it to bounce
    // back the AI response and save it into the DB.
    return new Response(stream);
  } catch (error) {
    throw new Error(`Couldn't handle request. ${error}`);
  }
}

async function getConversationContext(
  prompt: string,
  openai: OpenAI,
  signal: string,
) {
  const instructions = `
      Rule 1: For every user message, check whether the message asks for a plan, routine, diet guidance, health advice, fitness information, or any substantial topic related to well-being.
      Rule 2: If the message is "Give me a full diet plan for a serious hiker" return a random (not generic) title.
      Rule 3: If the message is too short or trivial (greetings, weather, unrelated topics), it does not qualify.
      Rule 4: If the message does not qualify, respond only with the text: false
      Rule 5: If the message does qualify, output a short conversation title with a maximum of 30 characters, plain text, no quotes, no formatting, and no additional content.
      Rule 6: Do not use markdown, headings, or line breaks. Output only what Rule 3 or Rule 4 requires.
      Rule 7: If the signal is a JSON form data, you will create a conversation title out of it.
      Rule 8: If the signal is "suggest" or "null", respond only with the text: false.
      Signal: ${signal}
    `;

  try {
    const response = await openai.responses.create({
      model: 'gpt-5.1',
      input: [
        {
          role: 'system',
          content: instructions,
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
    });

    // also cleaning the quotes off the string
    const conversationTitle = response.output_text.replace(/[\"\']/g, '');
    
    return conversationTitle;
  } catch (error) {
    throw new Error(`Couldn't get conversation context. ${error}`);
  }
}

async function saveConversationData(
  conversationId: string,
  date: string,
  prompt: string
) {
  // if there is an existing conversation
  // insert the received message into the respective conversation
  const sentMessage = await sql<Message[]>`
        INSERT INTO messages
        (sent_date, message_content, conversation_id, role, plan_saved)
        VALUES (${date}, ${prompt}, ${conversationId}, 'user', ${false})
        RETURNING *;
      `;

  // update the last message sent from this conversation
  await sql`
        UPDATE conversations
        SET last_message_date = ${sentMessage[0].sent_date}
        WHERE id = ${conversationId}
      `;
}

async function createNewConversation(
  localMessages: Message[],
  date: string,
  conversationTitle: string,
  user: User,
) {
  const brandNewConversation = await sql<Conversation[]>`
        INSERT INTO conversations
        (created_date, title, user_id)
        VALUES (${date}, ${conversationTitle}, ${user.id})
        RETURNING *;
      `;

  // inserting all messages before the conversation creation trigger
  for (let i = 0; i < localMessages.length; i++) {
    if (localMessages[i].message_content) {
      const {sent_date, message_content, role, form_data} = localMessages[i]; // destructuring of the a message
      await sql<Message[]>`
        INSERT INTO messages
        (sent_date, message_content, conversation_id, role, form_data, plan_saved)
        VALUES (
          ${sent_date},
          ${message_content},
          ${brandNewConversation[0].id},
          ${role},
          ${form_data ? sql.json(form_data as dietFormDataType) : null},
          ${false}
        );
      `;
    }
  }

  // update the last message sent column from the brand new conversation
  await sql`
        UPDATE conversations
        SET last_message_date = ${localMessages[localMessages.length - 1].sent_date}
        WHERE id = ${brandNewConversation[0].id}
      `;
}

// used to get conversations for nav links
export async function getLatestConversations(id: string) {
  try {
    // querying for user conversations in order to to display them in nav-links.tsx
    const userConversations = await sql<Conversation[]>`
      SELECT * FROM conversations
      WHERE user_id = ${id}
    `;

    return userConversations;
  } catch (error) {
    throw new Error(`Couldn't get the latest conversations. ${error}`);
  }
}

export async function getConversationHistory(localMessages: Message[]) {
  const allMessages: aiChatHistoryType[] = [];
  // sanitizing the conversation
  // history to only have valuable data
  localMessages.forEach((msg) => {
    allMessages.push({
      content: `${msg.message_content}`,
      role: msg.role,
    });
  });
  
  return allMessages;
}



export async function deleteConversation(id: string) {
  try {
    await sql`
      DELETE FROM conversations
      WHERE id = ${id};
    `
  } catch (error) {
    throw new Error(`Couldn't delete conversation. ${error}`)
  }
}

export async function unsavePlanFromMessage(planId: string) {
  try {
    await sql`
      UPDATE messages
      SET plan_saved = FALSE
      WHERE (form_data->>'id')::text = ${planId};
    `
  } catch (error) {
    throw new Error(`Couldn't unsave plan from message. ${error}`)
  }
}

export async function getConversationsCount(userId: string) {
  try {
    const conversationCount = await sql<{ count: number }[]>`
      SELECT COUNT(*) FROM conversations
      WHERE user_id = ${userId};
    `
    const total = conversationCount[0].count;
    return total;
  } catch (error) {
    throw new Error(`Couldn't get conversation count for the user. ${error}`);
  }
}

export async function getMessagesCount(userId: string) {
  try {
    const messagesCount = await sql<{ count: number }[]>`
      SELECT COUNT(messages.*) FROM messages
      JOIN conversations ON
       messages.conversation_id = conversations.id 
      WHERE conversations.user_id = ${userId};
    `
    const total = messagesCount[0].count;
    return total;
  } catch (error) {
    throw new Error(`Couldn't get messages count for the user. ${error}`);
  }
}

import { headers } from 'next/headers';

// gets base url dynamically
export async function getBaseUrl() {
  if (typeof window !== 'undefined') {
    // Browser runtime → relative works
    return '';
  }

  // Some runtimes give Promise<ReadonlyHeaders>
  const h = await headers();
  const host = h.get('host');
  const protocol = process.env.NODE_ENV === 'development' ? 'http' : 'https';

  return `${protocol}://${host}`;
}

export async function getUserProfilePicture(id: string) {
  try {
    const pictureQuery = await sql`
      SELECT * FROM user_profile_pictures
      WHERE user_id = ${id};
    `
    if (pictureQuery[0]) return pictureQuery[0].url;
    else return '';
  } catch (error) {
    throw new Error(`Couldn't get user profile picture. ${error}`)
  }
}