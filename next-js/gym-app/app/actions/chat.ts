import OpenAI from 'openai';
import { aiChatHistoryType, Conversation, Message, User } from '@/app/lib/definitions';
import postgres from 'postgres';

const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });

// handles user request upon sending a message to the AI
export async function handleRequest(req: Request, openai: OpenAI, conversationId: string) {
  const {
    prompt,
    user,
    conversation,
    date,
  }: {
    prompt: string;
    user: User;
    conversation: Conversation | null;
    date: string;
  } = await req.json();

  // all messages from the current conversation history
  const allMessages: aiChatHistoryType = []
  // instructions for the AI for it to parse the current conversation history
  let instructionsForConversationHistory: string = '';

  try {
    // create a conversation title if the prompt context
    // is valid and there is no valid conversation
    const conversationTitle = await getConversationContext(prompt, openai, conversation);

    // create a brand new conversation if there is no conversation
    // and conversationTitle returns a valid title
    if (!conversation && conversationTitle !== 'false') {
      await createNewConversation(
        date,
        conversationTitle,
        user,
        prompt
      );
    }

    // if there is a valid conversation and title returned false
    if (conversation && conversationTitle === 'false') await saveConversationData(conversation, date, prompt);

    if (conversationId !== '') {
      const conversationHistory = await sql<Message[]>`
        SELECT * FROM messages
        WHERE conversation_id = ${conversationId}
      `
      // sanitizing the conversation
      // history to only have valuable data 
      conversationHistory.forEach(msg => {
        allMessages.push({ messageContent: msg.message_content, sentDate: msg.sent_date, role: msg.role })
      })

      // updating the instructions
      instructionsForConversationHistory = `
        Here is all you need to know for the current conversation.
        This is the conversation history for you to talk with the user: ${JSON.stringify(conversationHistory)}.
      `
    }
 
    // getting the response from the AI
    const response = await openai.chat.completions.create({
      messages: [
        {
          role: 'system',
          content: `Basic all-knowing AI, respond me anything. Here is his/her first name ${user?.firstname}`,
        },
        {
          role: 'user',
          content: instructionsForConversationHistory + prompt,
        },
      ],
      model: 'gpt-3.5-turbo',
      stream: true,
      max_tokens: 300,
    });

    // creating a brand new readable stream
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder(); // UTF-8 encoder
        try {
          if (response) {
            for await (const chunk of response) {
              // partial string texts generated by the AI (content is the string inside the chunk)
              const content = chunk.choices[0]?.delta?.content || '';
              // encoding the strings to UTF-8 to be sent down the stream (content is the string inside the chunk)
              controller.enqueue(encoder.encode(content));
            }
          }
        } catch (error) {
          throw new Error(`Error: ${error}`);
        } finally {
          controller.close();
        }
      },
    });

    // You need to come up with a way to send the brand new conversation
    // object back to ai-chat.ts main function in order for it to bounce
    // back the AI response and save it into the DB.
    return new Response(stream);
  } catch (error) {
    throw new Error(`Couldn't handle request. ${error}`);
  }
  
}

async function getConversationContext(prompt: string, openai: OpenAI, conversation: Conversation | null) {
  const instructions = `
      Check if the user asked a valuable question or order:
      Is the user asking something about building a plan or ordering you
      to give valuable information about health or fitness?
      Is it a relevant topic for fitness or health eating?
      Is the question big enough for you to give the user a reasonable answer?

      If you think the question satisfies these basic checks, create a title for
      the conversation in order for me to save it to the db. The response should
      be only the title WITH NO QUOTES and the token limit is 30 characters!
      Else just output the text: 'false'

      User interactions that are not worth saving as conversations:
      User greeting you.
      Asking how the weather is.
      Asking about other topics other than fitness and well-being.

      FOLLOW THE USER PROMPT:\n
    `;

  try {

    if (conversation) {
      console.log(`There is already a valid conversation, terminating getConversationContext()...`)
      return 'false'
    }

    const response = await openai.responses.create({
      model: 'gpt-3.5-turbo',
      input: instructions + prompt,
    });

    // also cleaning the quotes off the string
    const conversationTitle = response.output_text.replace(/[\"\']/g, '');  

    console.log(
      `\nChecking if it's worth to create a conversation: ${conversationTitle}\n`
    );

    return conversationTitle;
  } catch (error) {
    throw new Error(`Couldn't get conversation context. ${error}`);
  }
}

async function saveConversationData(
  conversation: Conversation | null,
  date: string,
  prompt: string
) {

  console.log(`\nEntered saveConversationData(), saving data to an existing conversation...\n`)

  // if there is an existing conversation
  // insert the received message into the respective conversation
  const sentMessage = await sql<Message[]>`
        INSERT INTO messages
        (sent_date, message_content, conversation_id, role)
        VALUES (${date}, ${prompt}, ${conversation!.id}, 'user')
        RETURNING *;
      `;

  console.log(
    `\n1. Saved message "${sentMessage[0].message_content}" in conversation "${conversation!.title}"\n`
  );

  // update the last message sent from this conversation
  await sql`
        UPDATE conversations
        SET last_message_date = ${sentMessage[0].sent_date}
        where id = ${conversation!.id}
      `;
  console.log(
    `\n3. Updated the last_message_date column from the current conversation "${conversation!.title}".\n`
  );
}

async function createNewConversation(
  date: string,
  conversationTitle: string,
  user: User,
  prompt: string
) {

  console.log(`\nEntered createNewConversation(), creating a new conversation...\n`) 

  const brandNewConversation = await sql<Conversation[]>`
        INSERT INTO conversations
        (created_date, title, user_id)
        VALUES (${date}, ${conversationTitle}, ${user.id})
        RETURNING *;
      `;

  console.log(
    `\n1. Saved brand new conversation into DB: ${brandNewConversation[0].title}\n`
  );
  // insert the first user message
  const firstMessage = await sql<Message[]>`
        INSERT INTO messages
        (sent_date, message_content, conversation_id, role)
        VALUES (${date}, ${prompt}, ${brandNewConversation[0].id}, 'user')
        RETURNING *;
      `;

  console.log(
    `\n2. Inserted first message into ${brandNewConversation[0].title}, with the content "${firstMessage[0].message_content}"\n`
  );

  // update the last message sent column from the brand new conversation
  await sql`
        UPDATE conversations
        SET last_message_date = ${firstMessage[0].sent_date}
        WHERE id = ${brandNewConversation[0].id}
      `;
  console.log(
    `\n3. Updated the last_message_date column from the current conversation "${brandNewConversation[0].title}".\n`
  );

  // returning the brand new conversation object
  // return brandNewConversation[0];
}
