import OpenAI from 'openai';
import { aiChatHistoryType, Conversation, Message, User } from '@/app/lib/definitions';
import postgres from 'postgres';

const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });

// handles user request upon sending a message to the AI
export async function handleRequest(req: Request, openai: OpenAI, conversationId: string) {
  const {
    prompt,
    user,
    conversation,
    date,
  }: {
    prompt: string;
    user: User;
    conversation: Conversation | null;
    date: string;
  } = await req.json();

  // all messages from the current conversation history
  const allMessages: aiChatHistoryType = []
  // instructions for the AI for it to parse the current conversation history
  let conversationHistory: string = '';
  // conversation title
  let conversationTitle: string = '';

  const conversationRules = `
    Rule 1: You are an AI-powered fitness and diet planner in a web app with an 
    interactive assistant guiding users through customizable workout and diet plans, you are Diversus.
    Rule 2: Use Markdown language.
    Rule 3: Write new lines as \n tags.
    Rule 4: Always refer to the conversation history if provided as ordinary human would.
    Rule 5: Call the user by its name ${user.firstname}.
    Rule 6: Never send images.
  `

  try {
    if (conversation) {
      // if there is a valid conversation, save the user message into it
      await saveConversationData(conversation, date, prompt);
    } else {
      // trying to get a new conversation title
      conversationTitle = await getConversationContext(prompt, openai, conversation);

      // create a brand new conversation and insert the first user message into it if there is no conversation
      if (!conversationTitle.match(/false/i)) {
        await createNewConversation(
          date,
          conversationTitle,
          user,
          prompt
        );
      }
    }

    if (conversationId !== '') {
      // getting all messages from the current conversation
      const conversationHistoryQuery = await sql<Message[]>`
        SELECT * FROM messages
        WHERE conversation_id = ${conversationId}
      `
      // sanitizing the conversation
      // history to only have valuable data 
      conversationHistoryQuery.forEach(msg => {
        allMessages.push({ messageContent: msg.message_content, sentDate: msg.sent_date, role: msg.role })
      })

      // updating the instructions
      conversationHistory = `
        This is the conversation history: ${JSON.stringify(allMessages)}
      `
    }
 
    // getting the response from the AI
    const response = await openai.chat.completions.create({
      messages: [
        {
          role: 'system',
          content: conversationRules,
        },
        {
          role: 'assistant',
          content: conversationHistory,
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
      model: 'gpt-3.5-turbo',
      stream: true,
      max_tokens: 300,
    });

    // creating a brand new readable stream
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder(); // UTF-8 encoder
        try {
          if (response) {
            for await (const chunk of response) {
              // partial string texts generated by the AI (content is the string inside the chunk)
              const content = chunk.choices[0]?.delta?.content || '';
              // encoding the strings to UTF-8 to be sent down the stream (content is the string inside the chunk)
              controller.enqueue(encoder.encode(content));
            }
          }
        } catch (error) {
          throw new Error(`Error: ${error}`);
        } finally {
          controller.close();
        }
      },
    });

    // You need to come up with a way to send the brand new conversation
    // object back to ai-chat.ts main function in order for it to bounce
    // back the AI response and save it into the DB.
    return new Response(stream);
  } catch (error) {
    throw new Error(`Couldn't handle request. ${error}`);
  }
  
}

async function getConversationContext(prompt: string, openai: OpenAI, conversation: Conversation | null) {
  const instructions = `
      Rule 1: For every user message, check whether the message asks for a workout plan, diet guidance, health advice, fitness information, or any substantial topic related to well-being.

      Rule 2: If the message is too short or trivial (greetings, weather, unrelated topics), it does not qualify.

      Rule 3: If the message does not qualify, respond only with the text: false

      Rule 4: If the message does qualify, output a short conversation title with a maximum of 30 characters, plain text, no quotes, no formatting, and no additional content.

      Rule 5: Do not use markdown, headings, or line breaks. Output only what Rule 3 or Rule 4 requires.
    `;

  try {

    if (conversation) {
      return 'false'
    }

    const response = await openai.responses.create({
      model: 'gpt-3.5-turbo',
      input: instructions + prompt,
    });

    // also cleaning the quotes off the string
    const conversationTitle = response.output_text.replace(/[\"\']/g, '');  

    return conversationTitle;
  } catch (error) {
    throw new Error(`Couldn't get conversation context. ${error}`);
  }
}

async function saveConversationData(
  conversation: Conversation | null,
  date: string,
  prompt: string
) {

  // if there is an existing conversation
  // insert the received message into the respective conversation
  const sentMessage = await sql<Message[]>`
        INSERT INTO messages
        (sent_date, message_content, conversation_id, role)
        VALUES (${date}, ${prompt}, ${conversation!.id}, 'user')
        RETURNING *;
      `;

  // update the last message sent from this conversation
  await sql`
        UPDATE conversations
        SET last_message_date = ${sentMessage[0].sent_date}
        where id = ${conversation!.id}
      `;
}

async function createNewConversation(
  date: string,
  conversationTitle: string,
  user: User,
  prompt: string
) {

  const brandNewConversation = await sql<Conversation[]>`
        INSERT INTO conversations
        (created_date, title, user_id)
        VALUES (${date}, ${conversationTitle}, ${user.id})
        RETURNING *;
      `;

  // insert the first user message
  const firstMessage = await sql<Message[]>`
        INSERT INTO messages
        (sent_date, message_content, conversation_id, role)
        VALUES (${date}, ${prompt}, ${brandNewConversation[0].id}, 'user')
        RETURNING *;
      `;

  // update the last message sent column from the brand new conversation
  await sql`
        UPDATE conversations
        SET last_message_date = ${firstMessage[0].sent_date}
        WHERE id = ${brandNewConversation[0].id}
      `;
}

// used to get conversations for nav links
export async function getLatestConversations(id: string) {
  try {

    // querying for user conversations in order to to display them in nav-links.tsx
    const userConversations = await sql<Conversation[]>`
      SELECT * FROM conversations
      WHERE user_id = ${id}
    `

    return userConversations

  } catch (error) {
    throw new Error(`Couldn't get the latest conversations. ${error}`)
  }
}
